package com.boclips.videos.service.application.video

import com.boclips.events.config.Subscriptions
import com.boclips.events.types.VideoAnalysed
import com.boclips.events.types.VideoAnalysedTopic
import com.boclips.videos.service.domain.model.asset.AssetId
import com.boclips.videos.service.domain.model.asset.Topic
import com.boclips.videos.service.domain.model.asset.VideoAsset
import com.boclips.videos.service.domain.model.asset.VideoAssetRepository
import com.boclips.videos.service.domain.model.playback.PlaybackRepository
import com.boclips.videos.service.domain.service.video.VideoUpdateCommand.*
import mu.KLogging
import org.springframework.cloud.stream.annotation.StreamListener

class UpdateAnalysedVideo(
        private val playbackRepository: PlaybackRepository,
        private val videoAssetRepository: VideoAssetRepository
) {
    companion object : KLogging()

    @StreamListener(Subscriptions.VIDEO_ANALYSED)
    operator fun invoke(videoAnalysed: VideoAnalysed) {
        val videoId = videoAnalysed.videoId
        logger.info { "Updating analysed video $videoId" }
        val video = try {
            videoAssetRepository.find(AssetId(videoId))
        } catch (e: Exception) {
            logger.error(e) { "Error looking up video $videoId" }
            return
        }

        if (video == null) {
            logger.info { "Could not find video $videoId" }
            return
        }

        logger.info { "Updating metadata of video $videoId" }
        try {
            updateMetadata(video, videoAnalysed)
            logger.info { "Metadata of video $videoId updated" }
        } catch (e: Exception) {
            logger.error(e) { "Error updating metadata of video $videoId" }
        }

        if (videoAnalysed.transcript.isBlank()) {
            logger.info { "Deleting any existing auto-generated captions of video $videoId" }
            try {
                playbackRepository.deleteAutoGeneratedCaptions(video.playbackId, videoAnalysed.language)
                logger.info { "Not uploading captions of video $videoId because transcript is blank" }
            } catch (e: Exception) {
                logger.error(e) { "Error trying to delete existing captions of video $videoId" }
            }

            return
        }

        logger.info { "Uploading captions of video $videoId" }
        try {
            uploadCaptions(video, videoAnalysed)
            logger.info { "Captions of video $videoId uploaded" }
        } catch (e: Exception) {
            logger.error(e) { "Error uploading captions of video $videoId" }
        }
    }

    private fun updateMetadata(video: VideoAsset, analysedVideo: VideoAnalysed) {
        videoAssetRepository.bulkUpdate(listOf(
                ReplaceLanguage(video.assetId, analysedVideo.language),
                ReplaceTranscript(video.assetId, analysedVideo.transcript),
                ReplaceTopics(video.assetId, convertTopics(analysedVideo.topics)),
                ReplaceKeywords(video.assetId, (video.keywords + analysedVideo.keywords.map { it.name }).toSet())
        ))
    }

    private fun uploadCaptions(video: VideoAsset, analysedVideo: VideoAnalysed) {
        playbackRepository.uploadCaptions(video.playbackId, analysedVideo.captions)
    }

    private fun convertTopics(topics: List<VideoAnalysedTopic>): Set<Topic> {
        return topics.map(Topic.Companion::fromAnalysedVideoTopic).toSet()
    }
}
